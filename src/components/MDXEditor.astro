<!-- eslint-disable astro/sort-attributes, astro/jsx-a11y/prefer-tag-over-role, astro/jsx-a11y/control-has-associated-label -->
<div class="mdx-editor max-w-7xl mx-auto p-4">
  <div class="grid grid-cols-1 xl:grid-cols-3 gap-4 min-h-screen">
    <div class="xl:col-span-2 flex flex-col">
      <div class="mb-4">
        <h2 class="text-xl font-bold mb-2">MDX Editor</h2>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-4">
          <div>
            <label class="block text-sm font-medium mb-1" for="file-name"
              >ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆã‚¹ãƒ©ãƒƒã‚°ï¼‰</label
            >
            <input
              aria-label="è¨˜äº‹ã®ãƒ•ã‚¡ã‚¤ãƒ«å"
              class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
              id="file-name"
              type="text"
              value="new-article"
            />
          </div>
          <div>
            <label class="block text-sm font-medium mb-1" for="publish-date">å…¬é–‹æ—¥</label>
            <input
              aria-label="è¨˜äº‹ã®å…¬é–‹æ—¥"
              class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
              id="publish-date"
              type="date"
            />
          </div>
        </div>

        <div class="grid grid-cols-2 md:grid-cols-5 gap-2 mb-4">
          <button
            class="px-3 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors text-sm"
            id="new-btn">âœ¨ æ–°è¦</button
          >
          <button
            class="px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-sm"
            id="load-btn">ğŸ“‚ èª­è¾¼</button
          >
          <button
            class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm"
            id="save-btn">ğŸ’¾ ä¿å­˜</button
          >
          <button
            class="px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors text-sm"
            id="refresh-btn">ğŸ”„ æ›´æ–°</button
          >
          <button
            class="px-3 py-2 bg-sky-600 text-white rounded hover:bg-sky-700 transition-colors text-sm"
            id="generate-header-btn">ğŸ§© ãƒ˜ãƒƒãƒ€ç”Ÿæˆ</button
          >
        </div>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4">
          <button
            class="px-3 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition-colors text-sm"
            id="add-image-btn">ğŸ–¼ï¸ ç”»åƒè¿½åŠ </button
          >
          <button
            class="px-3 py-2 bg-cyan-600 text-white rounded hover:bg-cyan-700 transition-colors text-sm"
            id="add-captioned-btn">ğŸ“ ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ä»˜</button
          >
          <button
            class="px-3 py-2 bg-teal-600 text-white rounded hover:bg-teal-700 transition-colors text-sm"
            id="add-grid-btn">ğŸ”² ã‚°ãƒªãƒƒãƒ‰</button
          >
          <button
            class="px-3 py-2 bg-orange-600 text-white rounded hover:bg-orange-700 transition-colors text-sm"
            id="paste-image-btn">ğŸ“‹ è²¼ä»˜</button
          >
        </div>
      </div>

      <div
        class="mb-4 p-4 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg text-center bg-gray-50 dark:bg-gray-800 transition-colors"
        id="drop-zone"
        aria-label="ç”»åƒãƒ‰ãƒ­ãƒƒãƒ—é ˜åŸŸ"
      >
        <p class="text-gray-500 dark:text-gray-400 text-sm">
          ğŸ“ ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠï¼‰
        </p>
      </div>

      <textarea
        class="p-4 font-mono text-sm border border-gray-300 dark:border-gray-600 rounded resize-none bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
        id="mdx-input"
        placeholder="MDXã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å…¥åŠ›..."></textarea>
    </div>

    <div class="flex flex-col">
      <div class="mb-4">
        <h2 class="text-xl font-bold mb-2">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
      </div>

      <div
        class="p-4 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-900 prose dark:prose-invert max-w-none"
        id="preview-panel"
      >
        <p class="text-gray-500 italic">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>
      </div>
    </div>
  </div>
</div>

<!-- Header Generator Modal -->
<div
  class="fixed inset-0 bg-black/50 hidden z-50"
  id="header-modal"
  aria-modal="true"
  role="dialog"
>
  <div class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-lg w-full">
      <h3 class="text-lg font-bold mb-4">Astroå‘ã‘ãƒ˜ãƒƒãƒ€ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ï¼‰ç”Ÿæˆ</h3>

      <div class="mb-3">
        <label for="header-title" class="block text-sm font-medium mb-1">ã‚¿ã‚¤ãƒˆãƒ«</label>
        <input
          id="header-title"
          type="text"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
          placeholder="è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«"
        />
      </div>

      <div class="mb-3">
        <label for="header-description" class="block text-sm font-medium mb-1">èª¬æ˜</label>
        <input
          id="header-description"
          type="text"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
          placeholder="è¨˜äº‹ã®èª¬æ˜"
        />
      </div>

      <div class="mb-3">
        <label for="header-category" class="block text-sm font-medium mb-1">ã‚«ãƒ†ã‚´ãƒª</label>
        <select
          id="header-category"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
        >
          <option value="">ï¼ˆæœªé¸æŠï¼‰</option>
          <option value="å†™çœŸ">å†™çœŸ</option>
          <option value="æ—…è¡Œ">æ—…è¡Œ</option>
          <option value="ç«¶é¦¬">ç«¶é¦¬</option>
          <option value="æŠ€è¡“">æŠ€è¡“</option>
          <option value="ã‚¬ã‚¸ã‚§ãƒƒãƒˆ">ã‚¬ã‚¸ã‚§ãƒƒãƒˆ</option>
          <option value="ãã®ä»–">ãã®ä»–</option>
        </select>
      </div>

      <div class="mb-6">
        <label for="header-hero" class="block text-sm font-medium mb-1"
          >ãƒ’ãƒ¼ãƒ­ãƒ¼ç”»åƒï¼ˆä»»æ„ãƒ»ç›¸å¯¾ãƒ‘ã‚¹ï¼‰</label
        >
        <div class="flex gap-2">
          <input
            id="header-hero"
            type="text"
            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
            placeholder="./hero.jpg ã¾ãŸã¯ ./images/hero.jpg"
          />
          <button
            id="upload-hero-btn"
            class="px-3 py-2 bg-emerald-600 text-white rounded hover:bg-emerald-700 text-sm"
            type="button">Heroã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</button
          >
        </div>
        <input type="file" id="hidden-hero-input" accept="image/*" class="hidden" />
      </div>

      <div class="flex justify-end gap-2">
        <button
          class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
          id="cancel-header">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button
        >
        <button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700" id="apply-header"
          >æŒ¿å…¥/æ›´æ–°</button
        >
      </div>
    </div>
  </div>
</div>

<div class="mt-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg" id="uploaded-images">
  <h3 class="text-lg font-semibold mb-2">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”»åƒ</h3>
  <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-2" id="image-gallery"></div>
  <p class="text-xs text-gray-500 mt-2">
    â€» ç”»åƒã¯å…¬é–‹æ—¥ã«ã‚‚ã¨ã¥ã <code>src/content/blog/&lt;YYYY-MM&gt;/&lt;YYYY-MM-DD&gt;/images/</code
    > ã«è‡ªå‹•ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆé–‹ç™ºç’°å¢ƒã®ã¿ï¼‰ã€‚
  </p>
  <div class="sr-only" aria-live="polite" id="image-aria-live"></div>
  <input type="file" id="hidden-image-input" accept="image/*" multiple class="hidden" />
  <div class="hidden">
    <select id="captioned-image-select"></select>
  </div>
</div>

<!-- CaptionedImage Modal -->
<div
  class="fixed inset-0 bg-black/50 hidden z-50"
  id="captioned-modal"
  aria-modal="true"
  role="dialog"
>
  <div class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-lg w-full">
      <h3 class="text-lg font-bold mb-4">CaptionedImage ã‚’æŒ¿å…¥</h3>

      <div class="mb-4">
        <label class="block text-sm font-medium mb-2" for="captioned-image-select-visual"
          >ç”»åƒé¸æŠ</label
        >
        <select
          id="captioned-image-select-visual"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
        ></select>
      </div>

      <div class="mb-4">
        <label class="block text-sm font-medium mb-2" for="captioned-alt">Alt ãƒ†ã‚­ã‚¹ãƒˆ</label>
        <input
          id="captioned-alt"
          type="text"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
          placeholder="ç”»åƒã®èª¬æ˜"
        />
      </div>

      <div class="mb-6">
        <label class="block text-sm font-medium mb-2" for="captioned-caption"
          >ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ï¼ˆä»»æ„ï¼‰</label
        >
        <input
          id="captioned-caption"
          type="text"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
          placeholder="ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³"
        />
      </div>

      <div class="flex justify-end gap-2">
        <button
          class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
          id="cancel-captioned">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button
        >
        <button
          class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          id="apply-captioned">æŒ¿å…¥</button
        >
      </div>
    </div>
  </div>
</div>

<!-- ImageGrid Modal -->
<div class="fixed inset-0 bg-black/50 hidden z-50" id="grid-modal" aria-modal="true" role="dialog">
  <div class="flex items-center justify-center min-h-screen p-4">
    <div
      class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-2xl w-full max-h-[80vh] overflow-auto"
    >
      <h3 class="text-lg font-bold mb-4">ImageGrid ã‚’æŒ¿å…¥</h3>

      <div class="mb-4">
        <label class="block text-sm font-medium mb-2" for="grid-columns">ã‚°ãƒªãƒƒãƒ‰åˆ—æ•°</label>
        <select
          id="grid-columns"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
        >
          <option value="2">2åˆ—</option>
          <option value="3">3åˆ—</option>
          <option value="4">4åˆ—</option>
        </select>
      </div>

      <fieldset class="mb-4">
        <legend class="block text-sm font-medium mb-2">ç”»åƒé¸æŠï¼ˆè¤‡æ•°é¸æŠå¯ï¼‰</legend>
        <div
          id="grid-image-selection"
          class="max-h-60 overflow-auto border border-gray-300 dark:border-gray-600 rounded p-2 bg-gray-50 dark:bg-gray-900"
        >
        </div>
      </fieldset>

      <div class="mb-4" id="grid-selected-images"></div>

      <div class="flex justify-end gap-2">
        <button class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600" id="cancel-grid"
          >ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button
        >
        <button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700" id="apply-grid"
          >æŒ¿å…¥</button
        >
      </div>
    </div>
  </div>
</div>

<!-- Load MDX Modal -->
<div class="fixed inset-0 bg-black/50 hidden z-50" id="load-modal" aria-modal="true" role="dialog">
  <div class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-3xl w-full">
      <h3 class="text-lg font-bold mb-4">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã®MDXã‚’èª­ã¿è¾¼ã¿</h3>

      <div class="mb-3">
        <input
          id="load-search"
          type="search"
          class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800"
          placeholder="æ¤œç´¢ï¼ˆãƒ‘ã‚¹/ã‚¿ã‚¤ãƒˆãƒ«/æ—¥ä»˜ï¼‰"
        />
      </div>

      <div
        id="load-list"
        class="max-h-96 overflow-auto border border-gray-300 dark:border-gray-600 rounded"
      >
      </div>

      <div class="flex justify-end gap-2 mt-4">
        <button class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600" id="cancel-load"
          >é–‰ã˜ã‚‹</button
        >
      </div>
    </div>
  </div>
</div>

<script>
  class SimpleMDXEditor {
    input: HTMLTextAreaElement;
    preview: HTMLDivElement;
    fileName: HTMLInputElement;
    publishDate: HTMLInputElement;
    dropZone: HTMLDivElement;
    imageGallery: HTMLDivElement;
    captionedModal: HTMLDivElement;
    gridModal: HTMLDivElement;
    headerModal: HTMLDivElement;
    loadModal: HTMLDivElement;
    mdxList: any[];
    uploadedImages: Array<{ name: string; url: string; file: File }>;
    importMap: Record<string, string>;

    constructor() {
      this.input = document.getElementById('mdx-input') as HTMLTextAreaElement;
      this.preview = document.getElementById('preview-panel') as HTMLDivElement;
      this.fileName = document.getElementById('file-name') as HTMLInputElement;
      this.publishDate = document.getElementById('publish-date') as HTMLInputElement;
      this.dropZone = document.getElementById('drop-zone') as HTMLDivElement;
      this.imageGallery = document.getElementById('image-gallery') as HTMLDivElement;
      this.captionedModal = document.getElementById('captioned-modal') as HTMLDivElement;
      this.gridModal = document.getElementById('grid-modal') as HTMLDivElement;
      this.headerModal = document.getElementById('header-modal') as HTMLDivElement;
      this.loadModal = document.getElementById('load-modal') as HTMLDivElement;
      this.mdxList = [];

      this.uploadedImages = [];
      this.importMap = {};

      this.restore();
      this.setDefaultDate();
      this.bind();
      this.updatePreview();
      this.initDragAndDrop();
      this.initClipboardPaste();
      this.autoResizeTextarea();
    }

    setDefaultDate() {
      if (!this.publishDate.value) {
        const today = new Date().toISOString().split('T')[0];
        this.publishDate.value = today;
      }
    }

    bind() {
      this.input.addEventListener('input', () => {
        this.updatePreview();
        this.persist();
        this.autoResizeTextarea();
      });
      this.fileName.addEventListener('change', () => this.persist());
      this.publishDate.addEventListener('change', () => this.persist());

      document.getElementById('refresh-btn')?.addEventListener('click', () => this.updatePreview());
      document.getElementById('save-btn')?.addEventListener('click', () => this.saveMDX());
      document.getElementById('load-btn')?.addEventListener('click', () => this.openLoadModal());
      document.getElementById('new-btn')?.addEventListener('click', () => this.newTemplate());
      document
        .getElementById('generate-header-btn')
        ?.addEventListener('click', () => this.openHeaderModal());

      document
        .getElementById('add-image-btn')
        ?.addEventListener('click', () => this.addImageInput());
      document
        .getElementById('add-captioned-btn')
        ?.addEventListener('click', () => this.openCaptionedModal());
      document
        .getElementById('add-grid-btn')
        ?.addEventListener('click', () => this.openGridModal());
      document
        .getElementById('paste-image-btn')
        ?.addEventListener('click', () => this.pasteFromClipboard());

      document
        .getElementById('apply-captioned')
        ?.addEventListener('click', () => this.applyCaptionedImage());
      document
        .getElementById('cancel-captioned')
        ?.addEventListener('click', () => this.closeModal(this.captionedModal));
      document.getElementById('apply-grid')?.addEventListener('click', () => this.applyImageGrid());
      document
        .getElementById('cancel-grid')
        ?.addEventListener('click', () => this.closeModal(this.gridModal));
      document.getElementById('apply-header')?.addEventListener('click', () => this.applyHeader());
      document
        .getElementById('cancel-header')
        ?.addEventListener('click', () => this.closeModal(this.headerModal));
      document
        .getElementById('upload-hero-btn')
        ?.addEventListener('click', () => this.uploadHero());
    }

    updatePreview() {
      const content = this.input.value;

      // ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼é™¤å»
      let body = content.replace(/^---[\s\S]*?---\n?/, '');

      // import ã‚’è§£æã—ã€ç”»åƒã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã€‚æœ¬æ–‡ã‹ã‚‰ã¯ import è¡Œã‚’å–ã‚Šé™¤ã
      this.importMap = this.parseDefaultImageImports(body);
      if (Object.keys(this.importMap).length > 0) {
        body = body.replace(/^import\s+[A-Za-z_$][\w$]*\s+from\s+['"][^'"]+['"];?\s*$/gm, '');
      }

      // ç‹¬è‡ªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆCaptionedImage / ImageGridï¼‰ã®ç°¡æ˜“ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«ç½®æ›
      body = this.renderCustomComponents(body);

      // ä»–ã®æœªå¯¾å¿œãªã‚«ã‚¹ã‚¿ãƒ è¦ç´ ï¼ˆå…ˆé ­å¤§æ–‡å­—ã®ã‚¿ã‚°ï¼‰ã¯éè¡¨ç¤º
      body = body.replace(/<\/?[A-Z][^>]*>/g, '');

      // ç°¡æ˜“ Markdown â†’ HTML å¤‰æ›
      let html = body
        // è¦‹å‡ºã—
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        // ãƒªãƒ³ã‚¯
        .replace(
          /\[([^\]]+)\]\(([^\)]+)\)/g,
          '<a href="$2" class="text-blue-600 hover:underline">$1</a>'
        )
        // å¤ªå­—ãƒ»æ–œä½“
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        // ç”»åƒï¼ˆMarkdownï¼‰
        .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_m, alt) => {
          const src = this.placeholderDataURL(String(alt || 'image'), 300, 200);
          const escAlt = this.escapeHtml(String(alt || ''));
          return `<img src="${src}" alt="${escAlt}" class="max-w-full h-auto rounded border">`;
        })
        // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
        .replace(
          /```(\w+)?\n([\s\S]*?)```/g,
          '<pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded overflow-x-auto"><code>$2</code></pre>'
        )
        // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ¼ãƒ‰
        .replace(/`([^`]+)`/g, '<code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">$1</code>')
        // æ”¹è¡Œ
        .replace(/\n\n/g, '</p><p>')
        .replace(/\n/g, '<br>');

      // æ®µè½ã§å›²ã‚€
      if (html && !html.startsWith('<')) {
        html = '<p>' + html + '</p>';
      }

      this.preview.innerHTML =
        html || '<p class="text-gray-500 italic">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>';
      this.autoResizeTextarea();
    }

    // ----- Custom component preview helpers -----
    parseDefaultImageImports(input: string): Record<string, string> {
      const map: Record<string, string> = {};
      const re = /^import\s+([A-Za-z_$][\w$]*)\s+from\s+['"](.+?)['"];?/gm;
      let m: RegExpExecArray | null;
      while ((m = re.exec(input))) {
        const id = m[1];
        const p = m[2];
        if (/\.(png|jpe?g|webp|gif|svg)$/i.test(p)) {
          map[id] = p;
        }
      }
      return map;
    }
    renderCustomComponents(input: string): string {
      let out = input;

      // CaptionedImage (self-closing)
      out = out.replace(/<\s*CaptionedImage\b([^>]*)\/\s*>/g, (_m, attrs) =>
        this.renderCaptioned(attrs || '')
      );

      // CaptionedImage (with closing tag)
      out = out.replace(
        /<\s*CaptionedImage\b([^>]*)>([\s\S]*?)<\s*\/\s*CaptionedImage\s*>/g,
        (_m, attrs) => this.renderCaptioned(attrs || '')
      );

      // ImageGrid (self-closing only inæœ¬å®Ÿè£…)
      out = out.replace(/<\s*ImageGrid\b([^>]*)\/\s*>/g, (_m, attrs) =>
        this.renderImageGrid(attrs || '')
      );

      // Astro Image component (<Image ... />)
      out = out.replace(/<\s*Image\b([^>]*)\/\s*>/g, (_m, attrs) =>
        this.renderAstroImage(attrs || '')
      );
      // Fallback if someone writes with closing tag
      out = out.replace(/<\s*Image\b([^>]*)>([\s\S]*?)<\s*\/\s*Image\s*>/g, (_m, attrs) =>
        this.renderAstroImage(attrs || '')
      );

      return out;
    }

    renderCaptioned(attrs: string): string {
      const alt = this.readAttr(attrs, 'alt') || '';
      const caption = this.readAttr(attrs, 'caption') || '';
      const srcAttr = this.readAttr(attrs, 'src') || '';
      const width = Number(this.readAttr(attrs, 'width') || 600) || 600;
      const height = Number(this.readAttr(attrs, 'height') || 400) || 400;
      const resolved = this.resolveImageRef(srcAttr);
      const src = resolved || this.placeholderDataURL(alt || 'image', width, height);
      const esc = (s: string) => this.escapeHtml(s);
      const cap = caption
        ? `<figcaption class="mt-2 text-sm text-gray-500 italic">${esc(caption)}</figcaption>`
        : '';
      return `<figure class=\"not-prose my-6 text-center\"><img src=\"${src}\" alt=\"${esc(alt)}\" class=\"inline-block max-w-full h-auto rounded border shadow-sm\" width=\"${width}\" height=\"${height}\"/>${cap}</figure>`;
    }

    renderImageGrid(attrs: string): string {
      const columnsRaw = this.readAttr(attrs, 'columns');
      const cols = Math.min(
        4,
        Math.max(1, Number((columnsRaw || '2').replace(/[^0-9]/g, '')) || 2)
      );

      // Extract inside images={[ ... ]}
      const imagesMatch = attrs.match(/images\s*=\s*\{\s*\[([\s\S]*?)\]\s*\}/);
      const items: Array<{ src: string; alt: string; caption?: string }> = [];
      if (imagesMatch) {
        const body = imagesMatch[1];
        const objRe =
          /\{[^{}]*?src\s*:\s*(?:['"]([^'"\n]+)['"]|([A-Za-z_$][\w$]*))[^{}]*?alt\s*:\s*['"]([^'"\n]*)['"][^{}]*?(?:caption\s*:\s*['"]([^'"\n]*)['"])?.*?\}/g;
        let m: RegExpExecArray | null;
        while ((m = objRe.exec(body))) {
          const quoted = m[1];
          const ident = m[2];
          const alt = m[3] || '';
          const caption = m[4];
          const src = quoted || (ident ? this.importMap[ident] || '' : '');
          items.push({ src, alt, caption });
        }
      }

      const placeholder = (alt: string) => this.placeholderDataURL(alt || 'image', 300, 200);
      const esc = (s: string) => this.escapeHtml(s);
      const fallbackCount = Math.max(cols, 4);
      const list = items.length ? items : new Array(fallbackCount).fill({ alt: '' });
      const cards = list
        .map(it => {
          const imgSrc = it.src
            ? this.resolveImageRef(it.src) || placeholder(it.alt)
            : placeholder(it.alt);
          const figcap = it.caption
            ? `<figcaption class=\"mt-1 text-xs text-gray-500 italic\">${esc(it.caption)}</figcaption>`
            : '';
          return `<figure class=\"m-0 text-center\"><img src=\"${imgSrc}\" alt=\"${esc(it.alt || '')}\" class=\"w-full h-auto rounded border shadow-sm\"/>${figcap}</figure>`;
        })
        .join('');

      return `<div class=\"not-prose my-6\" style=\"display:grid;gap:.75rem;grid-template-columns:repeat(${cols},minmax(0,1fr));\">${cards}</div>`;
    }

    renderAstroImage(attrs: string): string {
      const alt = this.readAttr(attrs, 'alt') || '';
      const srcAttr = this.readAttr(attrs, 'src') || '';
      const width = Number(this.readAttr(attrs, 'width') || '') || undefined;
      const height = Number(this.readAttr(attrs, 'height') || '') || undefined;
      const cls = this.readAttr(attrs, 'class') || 'rounded border shadow-sm';
      const resolved = this.resolveImageRef(srcAttr);
      const src = resolved || this.placeholderDataURL(alt || 'image', width || 600, height || 400);
      const esc = (s: string) => this.escapeHtml(s);
      const size = `${width ? ` width=\"${width}\"` : ''}${height ? ` height=\"${height}\"` : ''}`;
      return `<img src=\"${src}\" alt=\"${esc(alt)}\" class=\"${esc(cls)}\"${size} />`;
    }

    readAttr(attrs: string, name: string): string | undefined {
      // Supports: name="..." | name='...' | name={...}
      const re = new RegExp(name + '\\s*=\\s*(\\"([^\\"]*)\\"|\'([^\']*)\'|\\{([^}]*)\\})');
      const m = attrs.match(re);
      if (!m) return undefined;
      return m[2] ?? m[3] ?? (m[4] ? String(m[4]) : undefined);
    }

    placeholderDataURL(text: string, width = 600, height = 400): string {
      const esc = this.escapeHtml(String(text || ''));
      const svg = `<?xml version="1.0" encoding="UTF-8"?><svg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}'><rect width='100%' height='100%' fill='#e5e7eb'/><text x='50%' y='50%' text-anchor='middle' dominant-baseline='middle' fill='#6b7280' font-size='20' font-family='sans-serif'>${esc}</text></svg>`;
      return 'data:image/svg+xml,' + encodeURIComponent(svg);
    }

    escapeHtml(s: string): string {
      return s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // ç”»åƒãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã®è§£æ±º: æ–‡å­—åˆ—ãƒ‘ã‚¹ or å¤‰æ•°åï¼ˆimportMapå‚ç…§ï¼‰â†’ dev API URL
    resolveImageRef(value: string | undefined): string | undefined {
      if (!value) return undefined;
      const v = String(value).trim();
      const pub = (document.getElementById('publish-date') as HTMLInputElement)?.value;
      if (!pub || !/^\d{4}-\d{2}-\d{2}$/.test(pub)) return undefined;
      const asPath = (p: string) => {
        const clean = p.replace(/^\.\//, '');
        return `/api/dev/get-image?publishDate=${encodeURIComponent(pub)}&path=${encodeURIComponent(clean)}`;
      };
      // å¤‰æ•°åã®å ´åˆã¯ importMap ã‹ã‚‰è§£æ±º
      if (/^[A-Za-z_$][\w$]*$/.test(v)) {
        const mapped = this.importMap[v];
        if (mapped) return asPath(mapped);
        return undefined;
      }
      // æ–‡å­—åˆ—ãƒ‘ã‚¹ï¼ˆä¾‹: ./images/foo.jpgï¼‰
      return asPath(v);
    }

    // ç”»åƒå‡¦ç†
    addImageInput() {
      const input = document.getElementById('hidden-image-input') as HTMLInputElement;
      input.onchange = evt => {
        const files = Array.from((evt.target as HTMLInputElement).files || []);
        this.handleFiles(files as File[]);
        input.value = '';
      };
      input.click();
    }

    initDragAndDrop() {
      if (!this.dropZone) return;
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(name => {
        this.dropZone.addEventListener(name, e => e.preventDefault());
        document.body.addEventListener(name, e => e.preventDefault());
      });
      ['dragenter', 'dragover'].forEach(name => {
        this.dropZone.addEventListener(name, () => {
          this.dropZone.classList.add('border-blue-400', 'bg-blue-50', 'dark:bg-blue-900');
        });
      });
      ['dragleave', 'drop'].forEach(name => {
        this.dropZone.addEventListener(name, () => {
          this.dropZone.classList.remove('border-blue-400', 'bg-blue-50', 'dark:bg-blue-900');
        });
      });
      this.dropZone.addEventListener('drop', e => {
        const files = Array.from((e as DragEvent).dataTransfer?.files || []);
        this.handleFiles(files as File[]);
      });
      // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
      this.dropZone.addEventListener('click', () => this.addImageInput());
    }

    handleFiles(files: File[]) {
      files.forEach(file => {
        if (file.type.startsWith('image/')) this.addImageToGallery(file);
      });
      this.updateImageSelects();
    }

    initClipboardPaste() {
      document.addEventListener('paste', evt => {
        const items = Array.from((evt as ClipboardEvent).clipboardData?.items || []);
        const imageItems = items.filter(i => i.type.startsWith('image/'));
        imageItems.forEach(item => {
          const file = item.getAsFile();
          if (file) {
            const ext = file.type.split('/')[1] || 'png';
            const named = new File([file], `pasted-${Date.now()}.${ext}`, { type: file.type });
            this.handleFiles([named]);
          }
        });
      });
    }

    async pasteFromClipboard() {
      try {
        // navigator.clipboard.read() ã¯ HTTPS/è¨±å¯ãŒå¿…è¦
        const items = await (navigator as any).clipboard.read();
        for (const item of items) {
          const imageTypes = item.types.filter((t: string) => t.startsWith('image/'));
          for (const t of imageTypes) {
            const blob = await item.getType(t);
            const ext = t.split('/')[1] || 'png';
            const file = new File([blob], `pasted-${Date.now()}.${ext}`, { type: t });
            this.handleFiles([file]);
          }
        }
        if (!items || items.length === 0) {
          alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚Ctrl+V ã§ã‚‚è²¼ã‚Šä»˜ã‘ã§ãã¾ã™ã€‚');
        }
      } catch {
        alert('ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆ¶ç´„ã§èª­ã¿å–ã‚Šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚Ctrl+V ã§è²¼ã‚Šä»˜ã‘ã—ã¦ãã ã•ã„ã€‚');
      }
    }

    async addImageToGallery(file: File) {
      const sanitizedName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
      const finalName = `${Date.now()}_${sanitizedName}`;
      const url = URL.createObjectURL(file);
      const entry = { name: finalName, url, file } as { name: string; url: string; file: File };
      this.uploadedImages.push(entry);
      this.refreshImageGallery();
      const live = document.getElementById('image-aria-live');
      if (live) live.textContent = `${finalName} ã‚’è¿½åŠ ã—ã¾ã—ãŸ`;

      // è‡ªå‹•ä¿å­˜ï¼ˆé–‹ç™ºç’°å¢ƒã®APIã«POSTï¼‰
      try {
        const saved = await this.uploadToServer(file, finalName, 'images');
        if (saved) {
          entry.name = saved;
          this.refreshImageGallery();
          this.updateImageSelects();
        }
      } catch (err) {
        console.warn('ç”»åƒã®è‡ªå‹•ä¿å­˜ã«å¤±æ•—:', err);
      }
    }

    refreshImageGallery() {
      if (!this.imageGallery) return;
      this.imageGallery.innerHTML = '';
      this.uploadedImages.forEach(img => {
        const wrap = document.createElement('div');
        wrap.className = 'relative group';
        const image = document.createElement('img');
        image.src = img.url;
        image.alt = img.name;
        image.className = 'w-full h-20 object-cover rounded border';
        image.addEventListener('click', () => this.insertImageReference(img.name));

        const del = document.createElement('button');
        del.type = 'button';
        del.textContent = 'Ã—';
        del.className =
          'absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity';
        del.addEventListener('click', ev => {
          ev.stopPropagation();
          this.removeImage(img.name);
        });

        const caption = document.createElement('p');
        caption.className = 'text-xs mt-1 truncate';
        caption.title = img.name;
        caption.textContent = img.name;

        wrap.appendChild(image);
        wrap.appendChild(del);
        this.imageGallery.appendChild(wrap);
        this.imageGallery.appendChild(caption);
      });
    }

    removeImage(name: string) {
      const idx = this.uploadedImages.findIndex(i => i.name === name);
      if (idx >= 0) {
        URL.revokeObjectURL(this.uploadedImages[idx].url);
        this.uploadedImages.splice(idx, 1);
        this.refreshImageGallery();
        this.updateImageSelects();
      }
    }

    updateImageSelects() {
      const select = document.getElementById('captioned-image-select-visual') as HTMLSelectElement;
      if (select) {
        select.innerHTML = '<option value="">ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
        this.uploadedImages.forEach(img => {
          const opt = document.createElement('option');
          opt.value = img.name;
          opt.text = img.name;
          select.appendChild(opt);
        });
      }

      const gridSelectZone = document.getElementById('grid-image-selection') as HTMLDivElement;
      if (gridSelectZone) {
        gridSelectZone.innerHTML = '';
        this.uploadedImages.forEach(img => {
          const row = document.createElement('label');
          row.className = 'flex items-center gap-2 p-1 cursor-pointer';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = img.name;
          const thumb = document.createElement('img');
          thumb.src = img.url;
          thumb.alt = img.name;
          thumb.className = 'w-12 h-12 object-cover rounded border';
          const span = document.createElement('span');
          span.className = 'text-sm';
          span.textContent = img.name;
          row.appendChild(cb);
          row.appendChild(thumb);
          row.appendChild(span);
          gridSelectZone.appendChild(row);
        });
        gridSelectZone.addEventListener('change', () => this.updateGridSelectedImages());
      }
    }

    insertImageReference(imageName: string) {
      const cursor = this.input.selectionStart;
      const before = this.input.value.slice(0, cursor);
      const after = this.input.value.slice(cursor);
      const imageRef = `![Image](./images/${imageName})`;
      this.input.value = before + imageRef + after;
      this.input.selectionStart = this.input.selectionEnd = cursor + imageRef.length;
      this.updatePreview();
      this.persist();
    }

    async uploadToServer(
      file: File,
      finalName: string,
      subdir: 'images' | '' = 'images'
    ): Promise<string | null> {
      const publishDate = this.publishDate.value;
      if (!publishDate || !/^\d{4}-\d{2}-\d{2}$/.test(publishDate)) {
        alert('ç”»åƒä¿å­˜ã«ã¯å…¬é–‹æ—¥ (YYYY-MM-DD) ã®å…¥åŠ›ãŒå¿…è¦ã§ã™');
        return null;
      }
      try {
        const endpoint = '/api/dev/upload-image';
        const named = new File([file], finalName, { type: file.type });
        const fd = new FormData();
        fd.append('publishDate', publishDate);
        fd.append('file', named, named.name);
        fd.append('subdir', subdir);
        const res = await fetch(endpoint, { method: 'POST', body: fd });
        if (!res.ok) throw new Error(`Upload failed: ${res.status}`);
        const data = await res.json();
        if (data?.ok && data.files?.[0]?.name) return String(data.files[0].name);
      } catch (e) {
        console.warn(e);
      }
      return null;
    }

    uploadHero() {
      const input = document.getElementById('hidden-hero-input') as HTMLInputElement;
      input.onchange = async evt => {
        const file = (evt.target as HTMLInputElement).files?.[0];
        if (!file) return;
        const sanitized = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
        const finalName = `${Date.now()}_${sanitized}`;
        const savedName = await this.uploadToServer(file, finalName, ''); // è¨˜äº‹ç›´ä¸‹ã«ä¿å­˜
        if (savedName) {
          (document.getElementById('header-hero') as HTMLInputElement).value = `./${savedName}`;
        } else {
          alert('Heroç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
        input.value = '';
      };
      input.click();
    }

    openCaptionedModal() {
      if (this.uploadedImages.length === 0) {
        alert('ã¾ãšç”»åƒã‚’è¿½åŠ ã—ã¦ãã ã•ã„');
        return;
      }
      this.captionedModal.classList.remove('hidden');
      this.updateImageSelects();
    }

    applyCaptionedImage() {
      const select = document.getElementById('captioned-image-select-visual') as HTMLSelectElement;
      const alt = document.getElementById('captioned-alt') as HTMLInputElement;
      const caption = document.getElementById('captioned-caption') as HTMLInputElement;
      if (!select?.value) return alert('ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„');
      if (!alt?.value.trim()) return alert('Alt ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      const cursor = this.input.selectionStart;
      const before = this.input.value.slice(0, cursor);
      const after = this.input.value.slice(cursor);
      let component = `<CaptionedImage\n  src="./images/${select.value}"\n  alt="${alt.value.trim()}"`;
      if (caption?.value.trim()) component += `\n  caption="${caption.value.trim()}"`;
      component += `\n/>\n`;
      this.input.value = before + component + after;
      this.updatePreview();
      this.persist();
      this.closeModal(this.captionedModal);
      if (select) select.value = '';
      if (alt) alt.value = '';
      if (caption) caption.value = '';
    }

    openGridModal() {
      if (this.uploadedImages.length === 0) {
        alert('ã¾ãšç”»åƒã‚’è¿½åŠ ã—ã¦ãã ã•ã„');
        return;
      }
      this.gridModal.classList.remove('hidden');
      this.updateImageSelects();
      this.updateGridSelectedImages();
    }

    updateGridSelectedImages() {
      const zone = document.getElementById('grid-selected-images') as HTMLDivElement;
      const checks = Array.from(
        document.querySelectorAll('#grid-image-selection input[type="checkbox"]')
      ) as HTMLInputElement[];
      const selected = checks.filter(cb => cb.checked).map(cb => cb.value);
      zone.innerHTML = '';
      if (selected.length === 0) return;
      const heading = document.createElement('h4');
      heading.className = 'font-semibold mb-2';
      heading.textContent = 'é¸æŠã—ãŸç”»åƒã®Alt/Caption';
      zone.appendChild(heading);
      selected.forEach(name => {
        const wrap = document.createElement('div');
        wrap.className = 'flex items-start gap-2 p-2 border rounded mb-2';
        const img = this.uploadedImages.find(i => i.name === name);
        if (img) {
          const thumb = document.createElement('img');
          thumb.src = img.url;
          thumb.alt = img.name;
          thumb.className = 'w-16 h-16 object-cover rounded';
          const fields = document.createElement('div');
          fields.className = 'flex-1';
          const alt = document.createElement('input');
          alt.type = 'text';
          alt.placeholder = 'Alt text';
          alt.setAttribute('data-image', name);
          alt.setAttribute('data-type', 'alt');
          alt.className = 'w-full p-1 mb-1 text-xs border rounded';
          const cap = document.createElement('input');
          cap.type = 'text';
          cap.placeholder = 'Caption (optional)';
          cap.setAttribute('data-image', name);
          cap.setAttribute('data-type', 'caption');
          cap.className = 'w-full p-1 text-xs border rounded';
          fields.appendChild(alt);
          fields.appendChild(cap);
          wrap.appendChild(thumb);
          wrap.appendChild(fields);
          zone.appendChild(wrap);
        }
      });
    }

    applyImageGrid() {
      const selectedAltInputs = Array.from(
        document.querySelectorAll('#grid-selected-images [data-type="alt"]')
      ) as HTMLInputElement[];
      const selectedNames = new Set(selectedAltInputs.map(i => i.getAttribute('data-image') || ''));
      const images: Array<{ src: string; alt: string; caption?: string }> = [];
      selectedNames.forEach(name => {
        if (!name) return;
        const alt = document.querySelector(
          `#grid-selected-images [data-image="${name}"][data-type="alt"]`
        ) as HTMLInputElement | null;
        const cap = document.querySelector(
          `#grid-selected-images [data-image="${name}"][data-type="caption"]`
        ) as HTMLInputElement | null;
        if (alt && alt.value.trim()) {
          const node: any = { src: `./images/${name}`, alt: alt.value.trim() };
          if (cap && cap.value.trim()) node.caption = cap.value.trim();
          images.push(node);
        }
      });
      if (images.length === 0) return alert('Alt ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      const columns = (document.getElementById('grid-columns') as HTMLSelectElement)?.value || '2';
      const cursor = this.input.selectionStart;
      const before = this.input.value.slice(0, cursor);
      const after = this.input.value.slice(cursor);
      let component = `<ImageGrid\n  columns={${columns}}\n  images={[\n`;
      images.forEach((img, i) => {
        component += `    {\n      src: "${img.src}",\n      alt: "${img.alt}"`;
        if ((img as any).caption) component += `,\n      caption: "${(img as any).caption}"`;
        component += `\n    }${i < images.length - 1 ? ',' : ''}\n`;
      });
      component += `  ]}\n/>\n`;
      this.input.value = before + component + after;
      this.updatePreview();
      this.persist();
      this.closeModal(this.gridModal);
    }

    closeModal(modal: HTMLDivElement) {
      modal.classList.add('hidden');
    }

    openHeaderModal() {
      this.headerModal.classList.remove('hidden');
      const fm = this.extractFrontmatter();
      const get = (k: string) => (fm[k] ?? '').toString();
      (document.getElementById('header-title') as HTMLInputElement).value = get('title');
      (document.getElementById('header-description') as HTMLInputElement).value =
        get('description');
      (document.getElementById('header-category') as HTMLSelectElement).value = get('category');
      (document.getElementById('header-hero') as HTMLInputElement).value = get('heroImage');
    }

    applyHeader() {
      const title = (document.getElementById('header-title') as HTMLInputElement).value.trim();
      const description = (
        document.getElementById('header-description') as HTMLInputElement
      ).value.trim();
      const category = (
        document.getElementById('header-category') as HTMLSelectElement
      ).value.trim();
      const heroImage = (document.getElementById('header-hero') as HTMLInputElement).value.trim();
      const pubDate = this.publishDate.value || new Date().toISOString().split('T')[0];

      const fmLines: string[] = ['---'];
      if (title) fmLines.push(`title: '${title.replace(/'/g, "''")}'`);
      if (description) fmLines.push(`description: '${description.replace(/'/g, "''")}'`);
      fmLines.push(`pubDate: '${pubDate}'`);
      if (category) fmLines.push(`category: '${category}'`);
      if (heroImage) fmLines.push(`heroImage: '${heroImage}'`);
      fmLines.push('---');

      const content = this.input.value;
      const hasFM = /^---[\s\S]*?---\n?/.test(content);
      const newContent = hasFM
        ? content.replace(/^---[\s\S]*?---\n?/, fmLines.join('\n') + '\n\n')
        : fmLines.join('\n') + '\n\n' + content;
      this.input.value = newContent;

      this.ensureImports();
      this.updatePreview();
      this.persist();
      this.closeModal(this.headerModal);
    }

    extractFrontmatter(): Record<string, string> {
      const m = this.input.value.match(/^---\n([\s\S]*?)\n---/);
      const out: Record<string, string> = {};
      if (!m) return out;
      const body = m[1];
      body.split(/\r?\n/).forEach(line => {
        const mm = line.match(/^(\w+):\s*(.*)$/);
        if (mm) out[mm[1]] = mm[2].replace(/^'|'$/g, '').trim();
      });
      return out;
    }

    ensureImports() {
      const content = this.input.value;
      const usedCaptioned = /<\s*CaptionedImage\b/.test(content);
      const usedGrid = /<\s*ImageGrid\b/.test(content);
      if (!usedCaptioned && !usedGrid) return;

      const fmMatch = content.match(/^---[\s\S]*?---\n?/);
      const startIndex = fmMatch ? fmMatch[0].length : 0;
      const head = content.slice(0, startIndex);
      let rest = content.slice(startIndex);

      const imports: string[] = [];
      if (usedCaptioned && !/import\s+CaptionedImage\s+from/.test(content)) {
        imports.push("import CaptionedImage from '@/components/CaptionedImage.astro';");
      }
      if (usedGrid && !/import\s+ImageGrid\s+from/.test(content)) {
        imports.push("import ImageGrid from '@/components/ImageGrid.astro';");
      }
      if (imports.length > 0) {
        rest = imports.join('\n') + '\n' + rest;
      }
      this.input.value = head + rest;
    }

    downloadMDX() {
      const content = this.input.value;
      const filename = this.fileName.value || 'article';

      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${filename}.mdx`;
      a.click();
      URL.revokeObjectURL(url);
    }

    async openLoadModal() {
      this.loadModal.classList.remove('hidden');
      await this.fetchMdxList();
      const search = document.getElementById('load-search') as HTMLInputElement;
      search.oninput = () => this.renderMdxList(search.value);
    }

    async fetchMdxList() {
      try {
        const res = await fetch('/api/dev/list-mdx');
        if (!res.ok) throw new Error('failed to list mdx');
        const data = await res.json();
        this.mdxList = (data?.files || []) as any[];
        this.renderMdxList('');
      } catch (e) {
        console.warn(e);
        const list = document.getElementById('load-list');
        if (list) list.innerHTML = '<div class="p-3 text-red-600">MDXã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
      }
    }

    renderMdxList(query: string) {
      const list = document.getElementById('load-list') as HTMLDivElement;
      if (!list) return;
      const q = (query || '').toLowerCase();
      const files = this.mdxList.filter((f: any) => {
        const key = `${f.path} ${f.title || ''} ${f.pubDate || ''}`.toLowerCase();
        return key.includes(q);
      });
      if (files.length === 0) {
        list.innerHTML =
          '<div class="p-3 text-sm text-gray-500">ä¸€è‡´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }
      const rows = files
        .map((f: any) => {
          const badge = f.pubDate
            ? `<span class="text-xs px-2 py-0.5 rounded bg-gray-200 dark:bg-gray-700 mr-2">${f.pubDate}</span>`
            : '';
          const title = f.title ? `<span class="font-medium">${escapeHtml(f.title)}</span>` : '';
          return `<button type="button" data-path="${encodeURIComponent(f.path)}" class="w-full text-left p-2 border-b border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 transition">
            <div class="text-sm flex items-center">${badge}${title}</div>
            <div class="text-xs text-gray-500">${escapeHtml(f.path)}</div>
          </button>`;
        })
        .join('');
      list.innerHTML = rows;
      list.querySelectorAll('button[data-path]')?.forEach((btn: any) => {
        btn.addEventListener('click', () => {
          const p = decodeURIComponent(btn.getAttribute('data-path'));
          this.loadMdxFromProject(p);
        });
      });
    }

    async loadMdxFromProject(relPath: string) {
      try {
        const res = await fetch(`/api/dev/read-mdx?path=${encodeURIComponent(relPath)}`);
        if (!res.ok) throw new Error('failed to read');
        const data = await res.json();
        const content = String(data?.content || '');
        this.input.value = content;
        // ãƒ•ã‚¡ã‚¤ãƒ«å
        this.fileName.value =
          relPath
            .split('/')
            .pop()
            ?.replace(/\.(mdx|md)$/i, '') || 'article';
        // pubDate ã¯FMãŒã‚ã‚Œã°å„ªå…ˆã€ãªã‘ã‚Œã°ãƒ‘ã‚¹ã‹ã‚‰æ¨æ¸¬
        const fm = this.extractFrontmatter();
        if (fm['pubDate']) {
          this.publishDate.value = fm['pubDate'];
        } else {
          const m = relPath.match(/^(\d{4}-\d{2})\/(\d{4}-\d{2}-\d{2})\//);
          if (m) this.publishDate.value = m[2];
        }
        this.updatePreview();
        this.persist();
        this.closeModal(this.loadModal);
      } catch (e) {
        alert('èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
        console.warn(e);
      }
    }

    newTemplate() {
      const today = new Date().toISOString().split('T')[0];
      this.publishDate.value = today;
      const template = `---
title: 'æ–°ã—ã„è¨˜äº‹'
description: 'è¨˜äº‹ã®èª¬æ˜'
pubDate: '${today}'
category: ''
---

# æ–°ã—ã„è¨˜äº‹

ã“ã“ã‹ã‚‰æœ¬æ–‡ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
`;
      this.input.value = template;
      this.fileName.value = 'new-article';
      this.updatePreview();
      this.persist();
    }

    async saveMDX() {
      const content = this.input.value;
      const filename = (this.fileName.value || 'article').trim();
      const publishDate = this.publishDate.value;
      if (!/^\d{4}-\d{2}-\d{2}$/.test(publishDate)) {
        alert('å…¬é–‹æ—¥ãŒä¸æ­£ã§ã™ (YYYY-MM-DD)');
        return;
      }
      try {
        const res = await fetch('/api/dev/save-mdx', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ publishDate, filename, content }),
        });
        const data = await res.json();
        if (!res.ok || !data?.ok) throw new Error(String(data?.error || res.status));
        const rel = data.path as string;
        alert(`ä¿å­˜ã—ã¾ã—ãŸ: ${rel}`);
        // æœ€æ–°ã®ä¸€è¦§ã‚’åæ˜ 
        await this.fetchMdxList();
      } catch (e: any) {
        alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + String(e?.message || e));
        console.warn(e);
      }
    }

    saveToLocalStorage() {
      const data = {
        content: this.input.value,
        fileName: this.fileName.value,
        publishDate: this.publishDate.value,
      };

      localStorage.setItem('mdx-editor-data', JSON.stringify(data));
    }

    persist() {
      this.saveToLocalStorage();
    }

    restore() {
      const savedData = localStorage.getItem('mdx-editor-data');

      if (savedData) {
        try {
          const data = JSON.parse(savedData);

          if (data.content) {
            this.input.value = data.content;
            this.updatePreview();
          }
          if (data.fileName) {
            this.fileName.value = data.fileName;
          }
          if (data.publishDate) {
            this.publishDate.value = data.publishDate;
          }
        } catch (e) {
          console.error('LocalStorageã‹ã‚‰ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
        }
      }
    }

    autoResizeTextarea() {
      if (!this.input) return;
      this.input.style.height = 'auto';
      const baseLine = 200; // px, ç´„10è¡Œç›¸å½“
      const next = Math.max(this.input.scrollHeight, baseLine);
      this.input.style.height = next + 'px';
      this.input.style.overflowY = 'hidden';
    }
  }

  // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ç”¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆXSSå¯¾ç­–ï¼‰
  function escapeHtml(s: string) {
    return s
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  new SimpleMDXEditor();
</script>
